"""
Script generator for augmentation pipelines.

Generates executable Python scripts that can run independently.
"""

from __future__ import annotations

from pathlib import Path
from textwrap import dedent
from typing import Any

from augmentai.core.policy import Policy, Transform


class ScriptGenerator:
    """Generate executable Python scripts for augmentation."""
    
    def __init__(self, backend: str = "albumentations") -> None:
        """
        Initialize generator.
        
        Args:
            backend: Augmentation backend (only "albumentations" supported)
        """
        if backend != "albumentations":
            raise ValueError(f"Unsupported backend: {backend}")
        self.backend = backend
    
    def generate_augment_script(
        self,
        policy: Policy,
        input_dir: str = "data",
        output_dir: str = "augmented",
        seed: int = 42,
    ) -> str:
        """
        Generate a standalone augmentation script.
        
        Args:
            policy: The augmentation policy
            input_dir: Input directory variable
            output_dir: Output directory variable
            seed: Random seed
            
        Returns:
            Complete Python script as string
        """
        transforms_code = self._generate_transforms(policy.transforms)
        
        script = f'''#!/usr/bin/env python3
"""
Auto-generated augmentation script.

Policy: {policy.name}
Domain: {policy.domain}
Generated by AugmentAI

Usage:
    python augment.py --input ./data --output ./augmented
"""

import argparse
import random
from pathlib import Path

import albumentations as A
from PIL import Image
import numpy as np


def create_pipeline(seed: int = {seed}) -> A.Compose:
    """Create the augmentation pipeline."""
    random.seed(seed)
    np.random.seed(seed)
    
    return A.Compose([
{transforms_code}
    ])


def augment_image(
    image_path: Path,
    output_path: Path,
    pipeline: A.Compose
) -> None:
    """Augment a single image."""
    # Load image
    image = np.array(Image.open(image_path).convert("RGB"))
    
    # Apply augmentation
    augmented = pipeline(image=image)
    augmented_image = augmented["image"]
    
    # Save result
    output_path.parent.mkdir(parents=True, exist_ok=True)
    Image.fromarray(augmented_image).save(output_path)


def process_directory(
    input_dir: Path,
    output_dir: Path,
    pipeline: A.Compose
) -> int:
    """Process all images in directory."""
    image_extensions = {{".jpg", ".jpeg", ".png", ".bmp", ".tiff", ".webp"}}
    count = 0
    
    for image_path in input_dir.rglob("*"):
        if image_path.is_file() and image_path.suffix.lower() in image_extensions:
            rel_path = image_path.relative_to(input_dir)
            output_path = output_dir / rel_path
            
            augment_image(image_path, output_path, pipeline)
            count += 1
            
            if count % 100 == 0:
                print(f"Processed {{count}} images...")
    
    return count


def main():
    parser = argparse.ArgumentParser(description="Apply augmentations to images")
    parser.add_argument("--input", "-i", type=Path, default=Path("{input_dir}"),
                        help="Input directory")
    parser.add_argument("--output", "-o", type=Path, default=Path("{output_dir}"),
                        help="Output directory")
    parser.add_argument("--seed", "-s", type=int, default={seed},
                        help="Random seed")
    args = parser.parse_args()
    
    print(f"AugmentAI - Processing {{args.input}}")
    print(f"Policy: {policy.name}")
    print(f"Domain: {policy.domain}")
    print(f"Seed: {{args.seed}}")
    
    pipeline = create_pipeline(args.seed)
    count = process_directory(args.input, args.output, pipeline)
    
    print(f"\\nComplete! Processed {{count}} images.")
    print(f"Output: {{args.output}}")


if __name__ == "__main__":
    main()
'''
        
        return script
    
    def _generate_transforms(self, transforms: list[Transform]) -> str:
        """Generate transform initialization code."""
        lines = []
        
        for t in transforms:
            params = self._format_params(t)
            lines.append(f"        A.{t.name}({params}),")
        
        return "\n".join(lines)
    
    def _format_params(self, transform: Transform) -> str:
        """Format transform parameters as function arguments."""
        params = []
        
        # Add probability
        params.append(f"p={transform.probability}")
        
        # Add other parameters
        for key, value in (transform.parameters or {}).items():
            if isinstance(value, str):
                params.append(f'{key}="{value}"')
            else:
                params.append(f"{key}={value}")
        
        return ", ".join(params)
    
    def generate_config_yaml(self, policy: Policy, seed: int = 42) -> str:
        """Generate YAML configuration file."""
        import yaml
        
        config = {
            "policy": {
                "name": policy.name,
                "domain": policy.domain,
                "seed": seed,
            },
            "transforms": [
                {
                    "name": t.name,
                    "probability": t.probability,
                    "parameters": t.parameters or {}
                }
                for t in policy.transforms
            ]
        }
        
        return yaml.dump(config, default_flow_style=False, sort_keys=False)
    
    def generate_requirements(self) -> str:
        """Generate requirements.txt content."""
        return dedent("""\
            albumentations>=1.3.0
            Pillow>=9.0.0
            numpy>=1.21.0
            PyYAML>=6.0
        """)
